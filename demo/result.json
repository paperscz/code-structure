[
  {
    "file": "src/index.ts",
    "results": [
      {
        "type": "call",
        "file": "src/index.ts",
        "line": 629,
        "text": "executeCommandLine().then(() => {",
        "children": [
          {
            "type": "call",
            "file": "src/index.ts",
            "line": 629,
            "text": "executeCommandLine().then(() => {",
            "children": [
              {
                "type": "definition",
                "file": "src/index.ts",
                "line": 472,
                "text": "async function executeCommandLine() {",
                "children": [
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 473,
                    "text": "minimist(process.argv.slice(2), { \"--\": true });",
                    "children": [
                      {
                        "type": "definition",
                        "file": "node_modules/@types/minimist/index.d.ts",
                        "line": 11,
                        "text": "declare function minimist(args?: string[], opts?: minimist.Opts): minimist.ParsedArgs;",
                        "children": [],
                        "fullText": "declare function minimist(args?: string[], opts?: minimist.Opts): minimist.ParsedArgs;"
                      }
                    ],
                    "fullText": "minimist(process.argv.slice(2), { \"--\": true })"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 477,
                    "text": "showToolVersion();",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 22,
                        "text": "function showToolVersion() {",
                        "children": [
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 23,
                            "text": "printInConsole(`Version: ${packageJson.version}`);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 14,
                                "text": "function printInConsole(message: any) {",
                                "children": [],
                                "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                              }
                            ],
                            "fullText": "printInConsole(`Version: ${packageJson.version}`)"
                          }
                        ],
                        "fullText": "function showToolVersion() {\n    printInConsole(`Version: ${packageJson.version}`);\n}"
                      }
                    ],
                    "fullText": "showToolVersion()"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 483,
                    "text": "globAsync(file)))));",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 26,
                        "text": "function globAsync(pattern: string) {",
                        "children": [],
                        "fullText": "function globAsync(pattern: string) {\n    return new Promise<string[]>((resolve, reject) => {\n        glob(pattern, (error, matches) => {\n            if (error) {\n                reject(error);\n            } else {\n                resolve(matches);\n            }\n        });\n    });\n}"
                      }
                    ],
                    "fullText": "globAsync(file)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 488,
                    "text": "minimatch(file, excludeFile)));",
                    "children": [
                      {
                        "type": "definition",
                        "file": "node_modules/@types/minimatch/index.d.ts",
                        "line": 9,
                        "text": "declare function M(target: string, pattern: string, options?: M.IOptions): boolean;",
                        "children": [],
                        "fullText": "declare function M(target: string, pattern: string, options?: M.IOptions): boolean;"
                      }
                    ],
                    "fullText": "minimatch(file, excludeFile)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 492,
                    "text": "printInConsole(file);",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 14,
                        "text": "function printInConsole(message: any) {",
                        "children": [],
                        "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                      }
                    ],
                    "fullText": "printInConsole(file)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 535,
                    "text": "getCodeStructure(node, {",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 119,
                        "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                        "children": [
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 136,
                            "text": "getCodeStructureOfDefinition(identifier, context, file);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 60,
                                "text": "function getCodeStructureOfDefinition(node: ts.Node, context: Context, file: string): Tree | Tree[] | undefined {",
                                "children": [
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 100,
                                    "text": "getCodeStructure(statement, context, sourceFile, definition.fileName);",
                                    "children": [
                                      {
                                        "type": "nested",
                                        "file": "src/index.ts",
                                        "line": 119,
                                        "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                        "children": [],
                                        "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                                      }
                                    ],
                                    "fullText": "getCodeStructure(statement, context, sourceFile, definition.fileName)"
                                  },
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 101,
                                    "text": "pushIntoTrees(tree.children, statementTree);",
                                    "children": [
                                      {
                                        "type": "definition",
                                        "file": "src/index.ts",
                                        "line": 42,
                                        "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                        "children": [],
                                        "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                                      }
                                    ],
                                    "fullText": "pushIntoTrees(tree.children, statementTree)"
                                  },
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 107,
                                    "text": "getCodeStructure(definitionNode, context, sourceFile, definition.fileName);",
                                    "children": [
                                      {
                                        "type": "nested",
                                        "file": "src/index.ts",
                                        "line": 119,
                                        "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                        "children": [],
                                        "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                                      }
                                    ],
                                    "fullText": "getCodeStructure(definitionNode, context, sourceFile, definition.fileName)"
                                  }
                                ],
                                "fullText": "function getCodeStructureOfDefinition(node: ts.Node, context: Context, file: string): Tree | Tree[] | undefined {\n    const definitions = context.languageService.getDefinitionAtPosition(file, node.end);\n    if (definitions && definitions.length > 0) {\n        const definition = definitions[0];\n        const sourceFile = context.program.getSourceFile(definition.fileName);\n        if (sourceFile) {\n            const definitionNode = sourceFile.forEachChild(child => {\n                if (child.pos < definition.textSpan.start && child.end > definition.textSpan.start + definition.textSpan.length) {\n                    return child;\n                }\n                return undefined;\n            });\n\n            if (definitionNode) {\n                if (definitionsCache.has(definitionNode)) {\n                    return definitionsCache.get(definitionNode);\n                }\n                const nestedNode = context.nodes.find(n => n === definitionNode);\n                let tree: Tree | Tree[] | undefined;\n                if (nestedNode) {\n                    tree = {\n                        node: nestedNode,\n                        sourceFile,\n                        type: JsonResultType.nested,\n                        children: [],\n                        file: definition.fileName,\n                    };\n                } else {\n                    if (definitionNode.kind === ts.SyntaxKind.FunctionDeclaration) {\n                        const declaration = definitionNode as ts.FunctionDeclaration;\n                        tree = {\n                            node: declaration,\n                            sourceFile,\n                            type: JsonResultType.definition,\n                            children: [],\n                            file: definition.fileName,\n                        };\n                        if (declaration.body) {\n                            context.nodes.push(definitionNode);\n                            for (const statement of declaration.body.statements) {\n                                const statementTree = getCodeStructure(statement, context, sourceFile, definition.fileName);\n                                pushIntoTrees(tree.children, statementTree);\n                            }\n                            context.nodes.pop();\n                        }\n                    } else {\n                        context.nodes.push(definitionNode);\n                        tree = getCodeStructure(definitionNode, context, sourceFile, definition.fileName);\n                        context.nodes.pop();\n                    }\n                }\n                definitionsCache.set(definitionNode, tree);\n                return tree;\n            }\n        }\n    }\n    return undefined;\n}"
                              }
                            ],
                            "fullText": "getCodeStructureOfDefinition(identifier, context, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 140,
                            "text": "getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 141,
                            "text": "pushIntoTrees(propertyAccessTrees, expressionTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(propertyAccessTrees, expressionTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 143,
                            "text": "getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 60,
                                "text": "function getCodeStructureOfDefinition(node: ts.Node, context: Context, file: string): Tree | Tree[] | undefined {",
                                "children": [
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 100,
                                    "text": "getCodeStructure(statement, context, sourceFile, definition.fileName);",
                                    "children": [
                                      {
                                        "type": "nested",
                                        "file": "src/index.ts",
                                        "line": 119,
                                        "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                        "children": [],
                                        "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                                      }
                                    ],
                                    "fullText": "getCodeStructure(statement, context, sourceFile, definition.fileName)"
                                  },
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 101,
                                    "text": "pushIntoTrees(tree.children, statementTree);",
                                    "children": [
                                      {
                                        "type": "definition",
                                        "file": "src/index.ts",
                                        "line": 42,
                                        "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                        "children": [],
                                        "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                                      }
                                    ],
                                    "fullText": "pushIntoTrees(tree.children, statementTree)"
                                  },
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 107,
                                    "text": "getCodeStructure(definitionNode, context, sourceFile, definition.fileName);",
                                    "children": [
                                      {
                                        "type": "nested",
                                        "file": "src/index.ts",
                                        "line": 119,
                                        "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                        "children": [],
                                        "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                                      }
                                    ],
                                    "fullText": "getCodeStructure(definitionNode, context, sourceFile, definition.fileName)"
                                  }
                                ],
                                "fullText": "function getCodeStructureOfDefinition(node: ts.Node, context: Context, file: string): Tree | Tree[] | undefined {\n    const definitions = context.languageService.getDefinitionAtPosition(file, node.end);\n    if (definitions && definitions.length > 0) {\n        const definition = definitions[0];\n        const sourceFile = context.program.getSourceFile(definition.fileName);\n        if (sourceFile) {\n            const definitionNode = sourceFile.forEachChild(child => {\n                if (child.pos < definition.textSpan.start && child.end > definition.textSpan.start + definition.textSpan.length) {\n                    return child;\n                }\n                return undefined;\n            });\n\n            if (definitionNode) {\n                if (definitionsCache.has(definitionNode)) {\n                    return definitionsCache.get(definitionNode);\n                }\n                const nestedNode = context.nodes.find(n => n === definitionNode);\n                let tree: Tree | Tree[] | undefined;\n                if (nestedNode) {\n                    tree = {\n                        node: nestedNode,\n                        sourceFile,\n                        type: JsonResultType.nested,\n                        children: [],\n                        file: definition.fileName,\n                    };\n                } else {\n                    if (definitionNode.kind === ts.SyntaxKind.FunctionDeclaration) {\n                        const declaration = definitionNode as ts.FunctionDeclaration;\n                        tree = {\n                            node: declaration,\n                            sourceFile,\n                            type: JsonResultType.definition,\n                            children: [],\n                            file: definition.fileName,\n                        };\n                        if (declaration.body) {\n                            context.nodes.push(definitionNode);\n                            for (const statement of declaration.body.statements) {\n                                const statementTree = getCodeStructure(statement, context, sourceFile, definition.fileName);\n                                pushIntoTrees(tree.children, statementTree);\n                            }\n                            context.nodes.pop();\n                        }\n                    } else {\n                        context.nodes.push(definitionNode);\n                        tree = getCodeStructure(definitionNode, context, sourceFile, definition.fileName);\n                        context.nodes.pop();\n                    }\n                }\n                definitionsCache.set(definitionNode, tree);\n                return tree;\n            }\n        }\n    }\n    return undefined;\n}"
                              }
                            ],
                            "fullText": "getCodeStructureOfDefinition(propertyAccessExpression.name, context, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 144,
                            "text": "pushIntoTrees(propertyAccessTrees, nameTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(propertyAccessTrees, nameTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 149,
                            "text": "getCodeStructureOfDefinition(newExpression.expression, context, file);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 60,
                                "text": "function getCodeStructureOfDefinition(node: ts.Node, context: Context, file: string): Tree | Tree[] | undefined {",
                                "children": [
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 100,
                                    "text": "getCodeStructure(statement, context, sourceFile, definition.fileName);",
                                    "children": [
                                      {
                                        "type": "nested",
                                        "file": "src/index.ts",
                                        "line": 119,
                                        "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                        "children": [],
                                        "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                                      }
                                    ],
                                    "fullText": "getCodeStructure(statement, context, sourceFile, definition.fileName)"
                                  },
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 101,
                                    "text": "pushIntoTrees(tree.children, statementTree);",
                                    "children": [
                                      {
                                        "type": "definition",
                                        "file": "src/index.ts",
                                        "line": 42,
                                        "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                        "children": [],
                                        "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                                      }
                                    ],
                                    "fullText": "pushIntoTrees(tree.children, statementTree)"
                                  },
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 107,
                                    "text": "getCodeStructure(definitionNode, context, sourceFile, definition.fileName);",
                                    "children": [
                                      {
                                        "type": "nested",
                                        "file": "src/index.ts",
                                        "line": 119,
                                        "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                        "children": [],
                                        "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                                      }
                                    ],
                                    "fullText": "getCodeStructure(definitionNode, context, sourceFile, definition.fileName)"
                                  }
                                ],
                                "fullText": "function getCodeStructureOfDefinition(node: ts.Node, context: Context, file: string): Tree | Tree[] | undefined {\n    const definitions = context.languageService.getDefinitionAtPosition(file, node.end);\n    if (definitions && definitions.length > 0) {\n        const definition = definitions[0];\n        const sourceFile = context.program.getSourceFile(definition.fileName);\n        if (sourceFile) {\n            const definitionNode = sourceFile.forEachChild(child => {\n                if (child.pos < definition.textSpan.start && child.end > definition.textSpan.start + definition.textSpan.length) {\n                    return child;\n                }\n                return undefined;\n            });\n\n            if (definitionNode) {\n                if (definitionsCache.has(definitionNode)) {\n                    return definitionsCache.get(definitionNode);\n                }\n                const nestedNode = context.nodes.find(n => n === definitionNode);\n                let tree: Tree | Tree[] | undefined;\n                if (nestedNode) {\n                    tree = {\n                        node: nestedNode,\n                        sourceFile,\n                        type: JsonResultType.nested,\n                        children: [],\n                        file: definition.fileName,\n                    };\n                } else {\n                    if (definitionNode.kind === ts.SyntaxKind.FunctionDeclaration) {\n                        const declaration = definitionNode as ts.FunctionDeclaration;\n                        tree = {\n                            node: declaration,\n                            sourceFile,\n                            type: JsonResultType.definition,\n                            children: [],\n                            file: definition.fileName,\n                        };\n                        if (declaration.body) {\n                            context.nodes.push(definitionNode);\n                            for (const statement of declaration.body.statements) {\n                                const statementTree = getCodeStructure(statement, context, sourceFile, definition.fileName);\n                                pushIntoTrees(tree.children, statementTree);\n                            }\n                            context.nodes.pop();\n                        }\n                    } else {\n                        context.nodes.push(definitionNode);\n                        tree = getCodeStructure(definitionNode, context, sourceFile, definition.fileName);\n                        context.nodes.pop();\n                    }\n                }\n                definitionsCache.set(definitionNode, tree);\n                return tree;\n            }\n        }\n    }\n    return undefined;\n}"
                              }
                            ],
                            "fullText": "getCodeStructureOfDefinition(newExpression.expression, context, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 153,
                            "text": "getCodeStructure(callExpression.expression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(callExpression.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 155,
                            "text": "showSyntaxKind(callExpression.expression);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 38,
                                "text": "function showSyntaxKind(node: ts.Node) {",
                                "children": [
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 39,
                                    "text": "printInConsole(node.kind);",
                                    "children": [
                                      {
                                        "type": "definition",
                                        "file": "src/index.ts",
                                        "line": 14,
                                        "text": "function printInConsole(message: any) {",
                                        "children": [],
                                        "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                                      }
                                    ],
                                    "fullText": "printInConsole(node.kind)"
                                  }
                                ],
                                "fullText": "function showSyntaxKind(node: ts.Node) {\n    printInConsole(node.kind);\n}"
                              }
                            ],
                            "fullText": "showSyntaxKind(callExpression.expression)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 157,
                            "text": "pushIntoTrees(tree.children, callTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(tree.children, callTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 166,
                            "text": "getCodeStructure(parameter, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(parameter, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 167,
                            "text": "pushIntoTrees(trees, parameterTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, parameterTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 174,
                            "text": "getCodeStructure(forOfStatement.statement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forOfStatement.statement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 178,
                            "text": "getCodeStructure(declaration.body, context, sourceFile, file) : undefined;",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(declaration.body, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 181,
                            "text": "getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 185,
                            "text": "getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 190,
                            "text": "getCodeStructure(expression.name, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(expression.name, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 193,
                            "text": "getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 224,
                            "text": "getCodeStructure(expression.expression, context, sourceFile, file) : undefined;",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(expression.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 231,
                            "text": "getCodeStructure(statement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(statement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 232,
                            "text": "pushIntoTrees(trees, childTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, childTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 236,
                            "text": "getCodeStructure(ifStatement.expression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(ifStatement.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 237,
                            "text": "pushIntoTrees(trees, ifTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, ifTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 239,
                            "text": "getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(ifStatement.thenStatement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 240,
                            "text": "pushIntoTrees(trees, thenTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, thenTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 243,
                            "text": "getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(ifStatement.elseStatement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 244,
                            "text": "pushIntoTrees(trees, elseTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, elseTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 248,
                            "text": "getCodeStructure(binaryExpression.left, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(binaryExpression.left, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 249,
                            "text": "pushIntoTrees(trees, leftTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, leftTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 251,
                            "text": "getCodeStructure(binaryExpression.right, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(binaryExpression.right, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 252,
                            "text": "pushIntoTrees(trees, rightTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, rightTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 255,
                            "text": "getCodeStructure(variableStatement.declarationList, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(variableStatement.declarationList, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 256,
                            "text": "pushIntoTrees(trees, declarationListTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, declarationListTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 260,
                            "text": "getCodeStructure(span, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(span, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 261,
                            "text": "pushIntoTrees(trees, spanTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, spanTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 266,
                            "text": "getCodeStructure(element, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(element, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 267,
                            "text": "pushIntoTrees(trees, elementTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, elementTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 272,
                            "text": "getCodeStructure(property, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(property, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 273,
                            "text": "pushIntoTrees(trees, propertyTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, propertyTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 278,
                            "text": "getCodeStructure(element, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(element, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 279,
                            "text": "pushIntoTrees(trees, elementTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, elementTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 284,
                            "text": "getCodeStructure(statement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(statement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 285,
                            "text": "pushIntoTrees(trees, statementTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, statementTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 289,
                            "text": "getCodeStructure(switchStatement.expression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(switchStatement.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 290,
                            "text": "pushIntoTrees(trees, switchTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, switchTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 292,
                            "text": "getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(switchStatement.caseBlock, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 293,
                            "text": "pushIntoTrees(trees, caseTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, caseTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 296,
                            "text": "getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 297,
                            "text": "pushIntoTrees(trees, trueTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, trueTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 299,
                            "text": "getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 300,
                            "text": "pushIntoTrees(trees, falseTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, falseTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 304,
                            "text": "getCodeStructure(clause, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(clause, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 305,
                            "text": "pushIntoTrees(trees, clauseTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, clauseTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 310,
                            "text": "getCodeStructure(forStatement.initializer, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forStatement.initializer, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 311,
                            "text": "pushIntoTrees(trees, initializerTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, initializerTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 315,
                            "text": "getCodeStructure(forStatement.condition, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forStatement.condition, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 316,
                            "text": "pushIntoTrees(trees, conditionTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, conditionTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 320,
                            "text": "getCodeStructure(forStatement.incrementor, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forStatement.incrementor, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 321,
                            "text": "pushIntoTrees(trees, incrementorTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, incrementorTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 324,
                            "text": "getCodeStructure(forStatement.statement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forStatement.statement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 325,
                            "text": "pushIntoTrees(trees, statementTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, statementTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 328,
                            "text": "getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(tryStatement.tryBlock, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 329,
                            "text": "pushIntoTrees(trees, tryBlockTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, tryBlockTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 332,
                            "text": "getCodeStructure(tryStatement.catchClause, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(tryStatement.catchClause, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 333,
                            "text": "pushIntoTrees(trees, catchClauseTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, catchClauseTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 337,
                            "text": "getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 338,
                            "text": "pushIntoTrees(trees, finallyBlockTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, finallyBlockTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 344,
                            "text": "getCodeStructure(declaration.initializer, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(declaration.initializer, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 345,
                            "text": "pushIntoTrees(trees, childTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, childTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 351,
                            "text": "getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 352,
                            "text": "pushIntoTrees(trees, variableDeclarationTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, variableDeclarationTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 355,
                            "text": "getCodeStructure(catchClause.block, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(catchClause.block, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 356,
                            "text": "pushIntoTrees(trees, blockTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, blockTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 359,
                            "text": "getCodeStructure(forInStatement.initializer, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forInStatement.initializer, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 360,
                            "text": "pushIntoTrees(trees, initializerTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, initializerTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 362,
                            "text": "getCodeStructure(forInStatement.expression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forInStatement.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 363,
                            "text": "pushIntoTrees(trees, expressionTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, expressionTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 365,
                            "text": "getCodeStructure(forInStatement.statement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(forInStatement.statement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 366,
                            "text": "pushIntoTrees(trees, statementTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, statementTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 369,
                            "text": "getCodeStructure(whileStatement.statement, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(whileStatement.statement, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 370,
                            "text": "pushIntoTrees(trees, statementTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, statementTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 372,
                            "text": "getCodeStructure(whileStatement.expression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(whileStatement.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 373,
                            "text": "pushIntoTrees(trees, expressionTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, expressionTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 376,
                            "text": "getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(elementAccessExpression.expression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 377,
                            "text": "pushIntoTrees(trees, statementTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, statementTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 380,
                            "text": "getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 381,
                            "text": "pushIntoTrees(trees, argumentExpressionTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, argumentExpressionTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 385,
                            "text": "getCodeStructure(functionExpression.body, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(functionExpression.body, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 386,
                            "text": "pushIntoTrees(trees, bodyTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, bodyTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 389,
                            "text": "getCodeStructure(functionExpression.name, context, sourceFile, file);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 119,
                                "text": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {",
                                "children": [],
                                "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                              }
                            ],
                            "fullText": "getCodeStructure(functionExpression.name, context, sourceFile, file)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 390,
                            "text": "pushIntoTrees(trees, nameTree);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 42,
                                "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                                "children": [],
                                "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                              }
                            ],
                            "fullText": "pushIntoTrees(trees, nameTree)"
                          },
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 415,
                            "text": "showSyntaxKind(node);",
                            "children": [
                              {
                                "type": "definition",
                                "file": "src/index.ts",
                                "line": 38,
                                "text": "function showSyntaxKind(node: ts.Node) {",
                                "children": [
                                  {
                                    "type": "call",
                                    "file": "src/index.ts",
                                    "line": 39,
                                    "text": "printInConsole(node.kind);",
                                    "children": [
                                      {
                                        "type": "definition",
                                        "file": "src/index.ts",
                                        "line": 14,
                                        "text": "function printInConsole(message: any) {",
                                        "children": [],
                                        "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                                      }
                                    ],
                                    "fullText": "printInConsole(node.kind)"
                                  }
                                ],
                                "fullText": "function showSyntaxKind(node: ts.Node) {\n    printInConsole(node.kind);\n}"
                              }
                            ],
                            "fullText": "showSyntaxKind(node)"
                          }
                        ],
                        "fullText": "function getCodeStructure(node: ts.Node, context: Context, sourceFile: ts.SourceFile, file: string): Tree | undefined | Tree[] {\n    if (node === undefined) {\n        return undefined;\n    }\n    if (node.kind === ts.SyntaxKind.CallExpression) {\n        const callExpression = node as ts.CallExpression;\n        const tree: Tree = {\n            node: callExpression,\n            sourceFile,\n            children: [],\n            type: JsonResultType.call,\n            file,\n        };\n        const trees: Tree[] = [];\n        let callTree: Tree | Tree[] | undefined;\n        if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n            const identifier = callExpression.expression as ts.Identifier;\n            callTree = getCodeStructureOfDefinition(identifier, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n            const propertyAccessExpression = callExpression.expression as ts.PropertyAccessExpression;\n            const propertyAccessTrees: Tree[] = [];\n            const expressionTree = getCodeStructure(propertyAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(propertyAccessTrees, expressionTree);\n\n            const nameTree = getCodeStructureOfDefinition(propertyAccessExpression.name, context, file);\n            pushIntoTrees(propertyAccessTrees, nameTree);\n\n            callTree = propertyAccessTrees.length > 0 ? propertyAccessTrees : undefined;\n        } else if (callExpression.expression.kind === ts.SyntaxKind.NewExpression) {\n            const newExpression = callExpression.expression as ts.NewExpression;\n            callTree = getCodeStructureOfDefinition(newExpression.expression, context, file);\n        } else if (callExpression.expression.kind === ts.SyntaxKind.CallExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ElementAccessExpression\n            || callExpression.expression.kind === ts.SyntaxKind.ParenthesizedExpression) {\n            callTree = getCodeStructure(callExpression.expression, context, sourceFile, file);\n        } else {\n            showSyntaxKind(callExpression.expression);\n        }\n        pushIntoTrees(tree.children, callTree);\n\n        if (tree.children.length > 0) {\n            trees.push(tree);\n        }\n\n        const parameters = callExpression.arguments;\n        if (parameters && parameters.length > 0) {\n            for (const parameter of parameters) {\n                const parameterTree = getCodeStructure(parameter, context, sourceFile, file);\n                pushIntoTrees(trees, parameterTree);\n            }\n        }\n\n        return trees.length > 0 ? trees : undefined;\n    } else if (node.kind === ts.SyntaxKind.ForOfStatement) {\n        const forOfStatement = node as ts.ForOfStatement;\n        return getCodeStructure(forOfStatement.statement, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ArrowFunction\n        || node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const declaration = node as ts.ArrowFunction | ts.ModuleDeclaration;\n        return declaration.body ? getCodeStructure(declaration.body, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.PropertyAssignment) {\n        const propertyAssignmentExpression = node as ts.PropertyAssignment;\n        return getCodeStructure(propertyAssignmentExpression.initializer, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PrefixUnaryExpression\n        || node.kind === ts.SyntaxKind.PostfixUnaryExpression) {\n        const prefixUnaryExpression = node as ts.PrefixUnaryExpression | ts.PostfixUnaryExpression;\n        return getCodeStructure(prefixUnaryExpression.operand, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.PropertyAccessExpression\n        || node.kind === ts.SyntaxKind.ExportSpecifier\n        || node.kind === ts.SyntaxKind.VariableDeclaration) {\n        const expression = node as ts.PropertyAccessExpression | ts.ExportSpecifier | ts.VariableDeclaration;\n        return getCodeStructure(expression.name, context, sourceFile, file);\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n        const exportDeclaration = node as ts.ExportDeclaration;\n        return exportDeclaration.exportClause ? getCodeStructure(exportDeclaration.exportClause, context, sourceFile, file) : undefined;\n    } else if (node.kind === ts.SyntaxKind.TemplateSpan\n        || node.kind === ts.SyntaxKind.ReturnStatement\n        || node.kind === ts.SyntaxKind.AsExpression\n        || node.kind === ts.SyntaxKind.SpreadElement\n        || node.kind === ts.SyntaxKind.ExpressionStatement\n        || node.kind === ts.SyntaxKind.AwaitExpression\n        || node.kind === ts.SyntaxKind.NewExpression\n        || node.kind === ts.SyntaxKind.ParenthesizedExpression\n        || node.kind === ts.SyntaxKind.TypeOfExpression\n        || node.kind === ts.SyntaxKind.NonNullExpression\n        || node.kind === ts.SyntaxKind.ThrowStatement\n        || node.kind === ts.SyntaxKind.ExportAssignment\n        || node.kind === ts.SyntaxKind.DeleteExpression\n        || node.kind === ts.SyntaxKind.VoidExpression\n        || node.kind === ts.SyntaxKind.TypeAssertionExpression) {\n        const expression = node as ts.TemplateSpan\n            | ts.ReturnStatement\n            | ts.AsExpression\n            | ts.SpreadElement\n            | ts.ExpressionStatement\n            | ts.AwaitExpression\n            | ts.NewExpression\n            | ts.ParenthesizedExpression\n            | ts.TypeOfExpression\n            | ts.NonNullExpression\n            | ts.ThrowStatement\n            | ts.ExportAssignment\n            | ts.DeleteExpression\n            | ts.VoidExpression\n            | ts.TypeAssertion;\n        return expression.expression ? getCodeStructure(expression.expression, context, sourceFile, file) : undefined;\n    } else {\n        const trees: Tree[] = [];\n        if (node.kind === ts.SyntaxKind.Block\n            || node.kind === ts.SyntaxKind.CaseClause) {\n            const statements = (node as ts.Block | ts.CaseClause).statements;\n            for (const statement of statements) {\n                const childTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, childTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.IfStatement) {\n            const ifStatement = node as ts.IfStatement;\n            const ifTree = getCodeStructure(ifStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, ifTree);\n\n            const thenTree = getCodeStructure(ifStatement.thenStatement, context, sourceFile, file);\n            pushIntoTrees(trees, thenTree);\n\n            if (ifStatement.elseStatement) {\n                const elseTree = getCodeStructure(ifStatement.elseStatement, context, sourceFile, file);\n                pushIntoTrees(trees, elseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.BinaryExpression) {\n            const binaryExpression = node as ts.BinaryExpression;\n            const leftTree = getCodeStructure(binaryExpression.left, context, sourceFile, file);\n            pushIntoTrees(trees, leftTree);\n\n            const rightTree = getCodeStructure(binaryExpression.right, context, sourceFile, file);\n            pushIntoTrees(trees, rightTree);\n        } else if (node.kind === ts.SyntaxKind.VariableStatement) {\n            const variableStatement = node as ts.VariableStatement;\n            const declarationListTree = getCodeStructure(variableStatement.declarationList, context, sourceFile, file);\n            pushIntoTrees(trees, declarationListTree);\n        } else if (node.kind === ts.SyntaxKind.TemplateExpression) {\n            const templateExpression = node as ts.TemplateExpression;\n            for (const span of templateExpression.templateSpans) {\n                const spanTree = getCodeStructure(span, context, sourceFile, file);\n                pushIntoTrees(trees, spanTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {\n            const arrayLiteralExpression = node as ts.ArrayLiteralExpression;\n            for (const element of arrayLiteralExpression.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n            const objectLiteralExpression = node as ts.ObjectLiteralExpression;\n            for (const property of objectLiteralExpression.properties) {\n                const propertyTree = getCodeStructure(property, context, sourceFile, file);\n                pushIntoTrees(trees, propertyTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.NamedExports) {\n            const namedExports = node as ts.NamedExports;\n            for (const element of namedExports.elements) {\n                const elementTree = getCodeStructure(element, context, sourceFile, file);\n                pushIntoTrees(trees, elementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ModuleBlock) {\n            const moduleBlock = node as ts.ModuleBlock;\n            for (const statement of moduleBlock.statements) {\n                const statementTree = getCodeStructure(statement, context, sourceFile, file);\n                pushIntoTrees(trees, statementTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.SwitchStatement) {\n            const switchStatement = node as ts.SwitchStatement;\n            const switchTree = getCodeStructure(switchStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, switchTree);\n\n            const caseTree = getCodeStructure(switchStatement.caseBlock, context, sourceFile, file);\n            pushIntoTrees(trees, caseTree);\n        } else if (node.kind === ts.SyntaxKind.ConditionalExpression) {\n            const conditionalExpression = node as ts.ConditionalExpression;\n            const trueTree = getCodeStructure(conditionalExpression.whenTrue, context, sourceFile, file);\n            pushIntoTrees(trees, trueTree);\n\n            const falseTree = getCodeStructure(conditionalExpression.whenFalse, context, sourceFile, file);\n            pushIntoTrees(trees, falseTree);\n        } else if (node.kind === ts.SyntaxKind.CaseBlock) {\n            const caseBlock = node as ts.CaseBlock;\n            for (const clause of caseBlock.clauses) {\n                const clauseTree = getCodeStructure(clause, context, sourceFile, file);\n                pushIntoTrees(trees, clauseTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.ForStatement) {\n            const forStatement = node as ts.ForStatement;\n            if (forStatement.initializer) {\n                const initializerTree = getCodeStructure(forStatement.initializer, context, sourceFile, file);\n                pushIntoTrees(trees, initializerTree);\n            }\n\n            if (forStatement.condition) {\n                const conditionTree = getCodeStructure(forStatement.condition, context, sourceFile, file);\n                pushIntoTrees(trees, conditionTree);\n            }\n\n            if (forStatement.incrementor) {\n                const incrementorTree = getCodeStructure(forStatement.incrementor, context, sourceFile, file);\n                pushIntoTrees(trees, incrementorTree);\n            }\n\n            const statementTree = getCodeStructure(forStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.TryStatement) {\n            const tryStatement = node as ts.TryStatement;\n            const tryBlockTree = getCodeStructure(tryStatement.tryBlock, context, sourceFile, file);\n            pushIntoTrees(trees, tryBlockTree);\n\n            if (tryStatement.catchClause) {\n                const catchClauseTree = getCodeStructure(tryStatement.catchClause, context, sourceFile, file);\n                pushIntoTrees(trees, catchClauseTree);\n            }\n\n            if (tryStatement.finallyBlock) {\n                const finallyBlockTree = getCodeStructure(tryStatement.finallyBlock, context, sourceFile, file);\n                pushIntoTrees(trees, finallyBlockTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n            const declarationList = node as ts.VariableDeclarationList;\n            for (const declaration of declarationList.declarations) {\n                if (declaration.initializer) {\n                    const childTree = getCodeStructure(declaration.initializer, context, sourceFile, file);\n                    pushIntoTrees(trees, childTree);\n                }\n            }\n        } else if (node.kind === ts.SyntaxKind.CatchClause) {\n            const catchClause = node as ts.CatchClause;\n            if (catchClause.variableDeclaration) {\n                const variableDeclarationTree = getCodeStructure(catchClause.variableDeclaration, context, sourceFile, file);\n                pushIntoTrees(trees, variableDeclarationTree);\n            }\n\n            const blockTree = getCodeStructure(catchClause.block, context, sourceFile, file);\n            pushIntoTrees(trees, blockTree);\n        } else if (node.kind === ts.SyntaxKind.ForInStatement) {\n            const forInStatement = node as ts.ForInStatement;\n            const initializerTree = getCodeStructure(forInStatement.initializer, context, sourceFile, file);\n            pushIntoTrees(trees, initializerTree);\n\n            const expressionTree = getCodeStructure(forInStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n\n            const statementTree = getCodeStructure(forInStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n        } else if (node.kind === ts.SyntaxKind.WhileStatement) {\n            const whileStatement = node as ts.WhileStatement;\n            const statementTree = getCodeStructure(whileStatement.statement, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            const expressionTree = getCodeStructure(whileStatement.expression, context, sourceFile, file);\n            pushIntoTrees(trees, expressionTree);\n        } else if (node.kind === ts.SyntaxKind.ElementAccessExpression) {\n            const elementAccessExpression = node as ts.ElementAccessExpression;\n            const statementTree = getCodeStructure(elementAccessExpression.expression, context, sourceFile, file);\n            pushIntoTrees(trees, statementTree);\n\n            if (elementAccessExpression.argumentExpression) {\n                const argumentExpressionTree = getCodeStructure(elementAccessExpression.argumentExpression, context, sourceFile, file);\n                pushIntoTrees(trees, argumentExpressionTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.FunctionExpression) {\n            const functionExpression = node as ts.FunctionExpression;\n            const bodyTree = getCodeStructure(functionExpression.body, context, sourceFile, file);\n            pushIntoTrees(trees, bodyTree);\n\n            if (functionExpression.name) {\n                const nameTree = getCodeStructure(functionExpression.name, context, sourceFile, file);\n                pushIntoTrees(trees, nameTree);\n            }\n        } else if (node.kind === ts.SyntaxKind.EndOfFileToken\n            || node.kind === ts.SyntaxKind.NumericLiteral\n            || node.kind === ts.SyntaxKind.StringLiteral\n            || node.kind === ts.SyntaxKind.ImportDeclaration\n            || node.kind === ts.SyntaxKind.MethodDeclaration\n            || node.kind === ts.SyntaxKind.FunctionDeclaration\n            || node.kind === ts.SyntaxKind.InterfaceDeclaration\n            || node.kind === ts.SyntaxKind.ShorthandPropertyAssignment\n            || node.kind === ts.SyntaxKind.Identifier\n            || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n            || node.kind === ts.SyntaxKind.EnumDeclaration\n            || node.kind === ts.SyntaxKind.TypeAliasDeclaration\n            || node.kind === ts.SyntaxKind.ImportEqualsDeclaration\n            || node.kind === ts.SyntaxKind.ClassDeclaration\n            || node.kind === ts.SyntaxKind.NullKeyword\n            || node.kind === ts.SyntaxKind.TrueKeyword\n            || node.kind === ts.SyntaxKind.FalseKeyword\n            || node.kind === ts.SyntaxKind.ThisKeyword\n            || node.kind === ts.SyntaxKind.BreakStatement\n            || node.kind === ts.SyntaxKind.ContinueStatement\n            || node.kind === ts.SyntaxKind.RegularExpressionLiteral) {\n            return undefined;\n        } else {\n            showSyntaxKind(node);\n            return undefined;\n        }\n        return trees.length > 0 ? trees : undefined;\n    }\n}"
                      }
                    ],
                    "fullText": "getCodeStructure(node, {\n                    nodes: [],\n                    program,\n                    languageService,\n                }, sourceFile, file)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 540,
                    "text": "pushIntoTrees(trees, tree);",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 42,
                        "text": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {",
                        "children": [],
                        "fullText": "function pushIntoTrees(trees: Tree[], tree: undefined | Tree | Tree[]) {\n    if (tree) {\n        if (Array.isArray(tree)) {\n            trees.push(...tree);\n        } else {\n            trees.push(tree);\n        }\n    }\n}"
                      }
                    ],
                    "fullText": "pushIntoTrees(trees, tree)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 548,
                    "text": "printInConsole(`${(Date.now() - now) / 1000.0} s`);",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 14,
                        "text": "function printInConsole(message: any) {",
                        "children": [],
                        "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                      }
                    ],
                    "fullText": "printInConsole(`${(Date.now() - now) / 1000.0} s`)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 577,
                    "text": "getJsonResult(tree)),",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 441,
                        "text": "function getJsonResult(tree: Tree): JsonResult {",
                        "children": [
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 454,
                            "text": "getJsonResult(child));",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 441,
                                "text": "function getJsonResult(tree: Tree): JsonResult {",
                                "children": [],
                                "fullText": "function getJsonResult(tree: Tree): JsonResult {\n    const startPosition = tree.node.getStart(tree.sourceFile);\n    const { line } = ts.getLineAndCharacterOfPosition(tree.sourceFile, startPosition);\n    const text = tree.sourceFile.text.substring(startPosition, tree.sourceFile.getLineEndOfPosition(startPosition)).trim();\n    const jsonResult: JsonResult = {\n        type: tree.type,\n        file: tree.file,\n        line,\n        text,\n        children: [],\n        fullText: tree.node.getText(tree.sourceFile),\n    };\n    for (const child of tree.children) {\n        jsonResult.children.push(getJsonResult(child));\n    }\n    return jsonResult;\n}"
                              }
                            ],
                            "fullText": "getJsonResult(child)"
                          }
                        ],
                        "fullText": "function getJsonResult(tree: Tree): JsonResult {\n    const startPosition = tree.node.getStart(tree.sourceFile);\n    const { line } = ts.getLineAndCharacterOfPosition(tree.sourceFile, startPosition);\n    const text = tree.sourceFile.text.substring(startPosition, tree.sourceFile.getLineEndOfPosition(startPosition)).trim();\n    const jsonResult: JsonResult = {\n        type: tree.type,\n        file: tree.file,\n        line,\n        text,\n        children: [],\n        fullText: tree.node.getText(tree.sourceFile),\n    };\n    for (const child of tree.children) {\n        jsonResult.children.push(getJsonResult(child));\n    }\n    return jsonResult;\n}"
                      }
                    ],
                    "fullText": "getJsonResult(tree)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 582,
                    "text": "mkdirp(dirname, error => {",
                    "children": [
                      {
                        "type": "definition",
                        "file": "node_modules/@types/mkdirp/index.d.ts",
                        "line": 7,
                        "text": "declare function mkdirp(dir: string, cb: (err: NodeJS.ErrnoException, made: string) => void): void;",
                        "children": [],
                        "fullText": "declare function mkdirp(dir: string, cb: (err: NodeJS.ErrnoException, made: string) => void): void;"
                      }
                    ],
                    "fullText": "mkdirp(dirname, error => {\n                    if (error) {\n                        printInConsole(error);\n                    } else {\n                        fs.writeFileSync(outpath, JSON.stringify(jsonResult, null, \"  \"));\n                    }\n                })"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 584,
                    "text": "printInConsole(error);",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 14,
                        "text": "function printInConsole(message: any) {",
                        "children": [],
                        "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                      }
                    ],
                    "fullText": "printInConsole(error)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 594,
                    "text": "mkdirp(dirname, error => {",
                    "children": [
                      {
                        "type": "definition",
                        "file": "node_modules/@types/mkdirp/index.d.ts",
                        "line": 7,
                        "text": "declare function mkdirp(dir: string, cb: (err: NodeJS.ErrnoException, made: string) => void): void;",
                        "children": [],
                        "fullText": "declare function mkdirp(dir: string, cb: (err: NodeJS.ErrnoException, made: string) => void): void;"
                      }
                    ],
                    "fullText": "mkdirp(dirname, error => {\n                    if (error) {\n                        printInConsole(error);\n                    } else {\n                        fs.createWriteStream(path.resolve(dirname, \"data.bundle.js\")).write(`var data = ${JSON.stringify(jsonResult)};`);\n                        fs.createReadStream(path.resolve(__dirname, \"../html/index.html\")).pipe(fs.createWriteStream(outpath));\n                        for (const filename of [\"index.bundle.js\", \"vendor.bundle.js\", \"vendor.bundle.css\"]) {\n                            fs.createReadStream(path.resolve(__dirname, `../html/${filename}`)).pipe(fs.createWriteStream(path.resolve(dirname, filename)));\n                        }\n                    }\n                })"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 596,
                    "text": "printInConsole(error);",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 14,
                        "text": "function printInConsole(message: any) {",
                        "children": [],
                        "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                      }
                    ],
                    "fullText": "printInConsole(error)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 613,
                    "text": "getTextResult(tree, 1);",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 422,
                        "text": "function getTextResult(tree: Tree, intent: number) {",
                        "children": [
                          {
                            "type": "call",
                            "file": "src/index.ts",
                            "line": 436,
                            "text": "getTextResult(child, intent + 1);",
                            "children": [
                              {
                                "type": "nested",
                                "file": "src/index.ts",
                                "line": 422,
                                "text": "function getTextResult(tree: Tree, intent: number) {",
                                "children": [],
                                "fullText": "function getTextResult(tree: Tree, intent: number) {\n    const startPosition = tree.node.getStart(tree.sourceFile);\n    const { line } = ts.getLineAndCharacterOfPosition(tree.sourceFile, startPosition);\n    const text = tree.sourceFile.text.substring(startPosition, tree.sourceFile.getLineEndOfPosition(startPosition)).trim();\n    let textResult = \"\";\n    if (tree.type === JsonResultType.call) {\n        textResult += `${\"  \".repeat(intent)}${line + 1} ${text}\\n`;\n    } else if (tree.type === JsonResultType.definition) {\n        textResult += `${\"  \".repeat(intent)}${text} ${tree.file} ${line + 1}\\n`;\n    } else if (tree.type === JsonResultType.nested) {\n        textResult += `${\"  \".repeat(intent)}${text} ${tree.file} ${line + 1}\\n`;\n    }\n\n    for (const child of tree.children) {\n        textResult += getTextResult(child, intent + 1);\n    }\n    return textResult;\n}"
                              }
                            ],
                            "fullText": "getTextResult(child, intent + 1)"
                          }
                        ],
                        "fullText": "function getTextResult(tree: Tree, intent: number) {\n    const startPosition = tree.node.getStart(tree.sourceFile);\n    const { line } = ts.getLineAndCharacterOfPosition(tree.sourceFile, startPosition);\n    const text = tree.sourceFile.text.substring(startPosition, tree.sourceFile.getLineEndOfPosition(startPosition)).trim();\n    let textResult = \"\";\n    if (tree.type === JsonResultType.call) {\n        textResult += `${\"  \".repeat(intent)}${line + 1} ${text}\\n`;\n    } else if (tree.type === JsonResultType.definition) {\n        textResult += `${\"  \".repeat(intent)}${text} ${tree.file} ${line + 1}\\n`;\n    } else if (tree.type === JsonResultType.nested) {\n        textResult += `${\"  \".repeat(intent)}${text} ${tree.file} ${line + 1}\\n`;\n    }\n\n    for (const child of tree.children) {\n        textResult += getTextResult(child, intent + 1);\n    }\n    return textResult;\n}"
                      }
                    ],
                    "fullText": "getTextResult(tree, 1)"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 618,
                    "text": "mkdirp(dirname, error => {",
                    "children": [
                      {
                        "type": "definition",
                        "file": "node_modules/@types/mkdirp/index.d.ts",
                        "line": 7,
                        "text": "declare function mkdirp(dir: string, cb: (err: NodeJS.ErrnoException, made: string) => void): void;",
                        "children": [],
                        "fullText": "declare function mkdirp(dir: string, cb: (err: NodeJS.ErrnoException, made: string) => void): void;"
                      }
                    ],
                    "fullText": "mkdirp(dirname, error => {\n                if (error) {\n                    printInConsole(error);\n                } else {\n                    fs.writeFileSync(outpath, textResult);\n                }\n            })"
                  },
                  {
                    "type": "call",
                    "file": "src/index.ts",
                    "line": 620,
                    "text": "printInConsole(error);",
                    "children": [
                      {
                        "type": "definition",
                        "file": "src/index.ts",
                        "line": 14,
                        "text": "function printInConsole(message: any) {",
                        "children": [],
                        "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
                      }
                    ],
                    "fullText": "printInConsole(error)"
                  }
                ],
                "fullText": "async function executeCommandLine() {\n    const argv = minimist(process.argv.slice(2), { \"--\": true });\n\n    const showVersion = argv.v || argv.version;\n    if (showVersion) {\n        showToolVersion();\n        return;\n    }\n\n    suppressError = argv.suppressError;\n\n    let uniqFiles = uniq(flatten(await Promise.all(argv._.map(file => globAsync(file)))));\n\n    const exclude: string | string[] | undefined = argv.exclude;\n    if (exclude) {\n        const excludes = Array.isArray(exclude) ? exclude : [exclude];\n        uniqFiles = uniqFiles.filter(file => excludes.every(excludeFile => !minimatch(file, excludeFile)));\n    }\n\n    for (const file of uniqFiles) {\n        printInConsole(file);\n    }\n\n    const out: string | string | undefined = argv.o;\n\n    const compilerOptions: ts.CompilerOptions = { target: ts.ScriptTarget.ESNext, allowJs: true };\n    const languageService = ts.createLanguageService({\n        getCompilationSettings() {\n            return compilerOptions;\n        },\n        getScriptFileNames() {\n            return uniqFiles;\n        },\n        getScriptVersion(fileName: string) {\n            return \"\";\n        },\n        getScriptSnapshot(fileName: string) {\n            if (fileName === \".ts\") {\n                return ts.ScriptSnapshot.fromString(\"\");\n            }\n            return ts.ScriptSnapshot.fromString(fs.readFileSync(fileName, { encoding: \"utf8\" }));\n        },\n        getCurrentDirectory: () => \".\",\n        getDefaultLibFileName(options: ts.CompilerOptions) {\n            return ts.getDefaultLibFilePath(options);\n        },\n        fileExists: ts.sys.fileExists,\n        readFile: ts.sys.readFile,\n        readDirectory: ts.sys.readDirectory,\n    });\n\n    const program = ts.createProgram(uniqFiles, compilerOptions);\n\n    const results: Result[] = [];\n\n    const now = Date.now();\n\n    for (const file of uniqFiles) {\n        const sourceFile = program.getSourceFile(file);\n\n        if (sourceFile) {\n            const trees: Tree[] = [];\n            sourceFile.forEachChild(node => {\n                const tree = getCodeStructure(node, {\n                    nodes: [],\n                    program,\n                    languageService,\n                }, sourceFile, file);\n                pushIntoTrees(trees, tree);\n            });\n            if (trees.length > 0) {\n                results.push({ file, trees });\n            }\n        }\n    }\n\n    printInConsole(`${(Date.now() - now) / 1000.0} s`);\n\n    let jsonOutput: string[] = [];\n    let htmlOutput: string[] = [];\n    let othersOutput: string[] = [];\n    let outPaths: string[] = [];\n    if (typeof out === \"string\") {\n        outPaths.push(out);\n    } else if (Array.isArray(out)) {\n        outPaths = out;\n    }\n    for (const outpath of outPaths) {\n        if (typeof outpath === \"string\") {\n            if (outpath.endsWith(\".json\")) {\n                jsonOutput.push(outpath);\n            } else if (outpath.endsWith(\".html\")) {\n                htmlOutput.push(outpath);\n            } else {\n                othersOutput.push(outpath);\n            }\n        }\n    }\n    jsonOutput = uniq(jsonOutput);\n    htmlOutput = uniq(htmlOutput);\n    othersOutput = uniq(othersOutput);\n\n    if (jsonOutput.length > 0 || htmlOutput.length > 0) {\n        const jsonResult: JsonDataResult[] = results.map(result => ({\n            file: result.file,\n            results: result.trees.map(tree => getJsonResult(tree)),\n        }));\n        if (jsonOutput.length > 0) {\n            for (const outpath of jsonOutput) {\n                const dirname = path.dirname(outpath);\n                mkdirp(dirname, error => {\n                    if (error) {\n                        printInConsole(error);\n                    } else {\n                        fs.writeFileSync(outpath, JSON.stringify(jsonResult, null, \"  \"));\n                    }\n                });\n            }\n        }\n        if (htmlOutput.length > 0) {\n            for (const outpath of htmlOutput) {\n                const dirname = path.dirname(outpath);\n                mkdirp(dirname, error => {\n                    if (error) {\n                        printInConsole(error);\n                    } else {\n                        fs.createWriteStream(path.resolve(dirname, \"data.bundle.js\")).write(`var data = ${JSON.stringify(jsonResult)};`);\n                        fs.createReadStream(path.resolve(__dirname, \"../html/index.html\")).pipe(fs.createWriteStream(outpath));\n                        for (const filename of [\"index.bundle.js\", \"vendor.bundle.js\", \"vendor.bundle.css\"]) {\n                            fs.createReadStream(path.resolve(__dirname, `../html/${filename}`)).pipe(fs.createWriteStream(path.resolve(dirname, filename)));\n                        }\n                    }\n                });\n            }\n        }\n    }\n    if (othersOutput.length > 0) {\n        let textResult = \"\";\n        for (const result of results) {\n            textResult += `${result.file}\\n`;\n            for (const tree of result.trees) {\n                textResult += getTextResult(tree, 1);\n            }\n        }\n        for (const outpath of othersOutput) {\n            const dirname = path.dirname(outpath);\n            mkdirp(dirname, error => {\n                if (error) {\n                    printInConsole(error);\n                } else {\n                    fs.writeFileSync(outpath, textResult);\n                }\n            });\n        }\n    }\n}"
              }
            ],
            "fullText": "executeCommandLine()"
          }
        ],
        "fullText": "executeCommandLine().then(() => {\n    printInConsole(\"code-structure success.\");\n}, error => {\n    printInConsole(error);\n    if (!suppressError) {\n        process.exit(1);\n    }\n})"
      },
      {
        "type": "call",
        "file": "src/index.ts",
        "line": 630,
        "text": "printInConsole(\"code-structure success.\");",
        "children": [
          {
            "type": "definition",
            "file": "src/index.ts",
            "line": 14,
            "text": "function printInConsole(message: any) {",
            "children": [],
            "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
          }
        ],
        "fullText": "printInConsole(\"code-structure success.\")"
      },
      {
        "type": "call",
        "file": "src/index.ts",
        "line": 632,
        "text": "printInConsole(error);",
        "children": [
          {
            "type": "definition",
            "file": "src/index.ts",
            "line": 14,
            "text": "function printInConsole(message: any) {",
            "children": [],
            "fullText": "function printInConsole(message: any) {\n    if (message instanceof Error) {\n        message = message.message;\n    }\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}"
          }
        ],
        "fullText": "printInConsole(error)"
      }
    ]
  }
]